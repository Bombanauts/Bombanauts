<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="socket.io/socket.io.js" defer async></script>
    <script src="bundle.js" defer async></script>
    <!-- <script src="browser/game/main.js" defer async></script> -->
     <style>
            html, body {
                width: 100%;
                height: 100%;
            }
            body {
                background-color: #ffffff;
                margin: 0;
                overflow: hidden;
                font-family: arial;
            }
            #blocker {
                position: absolute;
                width: 100%;
                height: 100%;
                background-color: rgba(0,0,0,0.5);
            }
            #instructions {
                width: 100%;
                height: 100%;
                display: -webkit-box;
                display: -moz-box;
                display: box;
                -webkit-box-orient: horizontal;
                -moz-box-orient: horizontal;
                box-orient: horizontal;
                -webkit-box-pack: center;
                -moz-box-pack: center;
                box-pack: center;
                -webkit-box-align: center;
                -moz-box-align: center;
                box-align: center;
                color: #ffffff;
                text-align: center;
                cursor: pointer;
            }
        </style>
  </head>
  <body>
    <!-- <div id="app"></div> -->
    <div id="blocker">

            <div id="instructions">
                <span style="font-size:40px">Click to play</span>
                <br />
                (W,A,S,D = Move, SPACE = Jump, MOUSE = Look, CLICK = Shoot)
            </div>

        </div>
    <script>
    //       let scene;
    // let camera;
    // let renderer;
    // let geometry;
    // let materail;
    // let mesh;

    // // CANNON JS Global Variables
    // let world;

    // // run our init function
    // init();

    // // init THREE JS world
    //  function init() {

    //   // init scene
    //   scene = new THREE.Scene()

    //   // init camera
    //   camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 1,2500)

    //   // add camera to scene
    //   scene.add(camera)

    //   // make the ground
    //   geometry = new THREE.PlaneGeometry(300, 300, 50, 50);

    //   // rotate ground 90 degrees and give sthe ground a vector representation
    //   // as in the ground is now a vector instead of just an object
    //   // allows manipulations like rotation, scale, translation, etc.
    //   geometry.applyMatrix( new THREE.Matrix4().makeRotationX(-Math.PI / 2))

    //   // MeshLambertMaterial is a dull kind of color for non shiny non metalic stuff
    //   // the color code I picked is like dark green because why not? :)
    //   material = new THREE.MeshLambertMaterial( { color:  0x002600 })

    //   // make mesh and combine the geometry and styling
    //   mesh = new THREE.Mesh( geometry, material );

    //   // add some cool shadow affects;
    //   mesh.castShadow = true;
    //   mesh.receiveShadow = true;

    //   // finally add it to the scene
    //   scene.add( mesh )

    //   renderer = new THREE.WebGLRenderer()
    //   renderer.shadowMapEnabled = true;
    //   renderer.shadowMapSoft = true;
    //   renderer.setSize( window.innerWidth, window.innerHeight );

    //   document.body.appendChild( renderer.domElement );

    // }


  var PointerLockControls = function(camera, cannonBody) {

      var eyeYPos = 2; // eyes are 2 meters above the ground
      var velocityFactor = 0.2;
      var jumpVelocity = 20;
      var scope = this;

      var pitchObject = new THREE.Object3D();
      pitchObject.add(camera);

    var moveForward = false;
    var moveBackward = false;
    var moveLeft = false;
    var moveRight = false;

      var yawObject = new THREE.Object3D();
      yawObject.position.y = 2;
      yawObject.add(pitchObject);

      var quat = new THREE.Quaternion();

      var moveForward = false;
      var moveBackward = false;
      var moveLeft = false;
      var moveRight = false;

      var canJump = false;

      var contactNormal = new CANNON.Vec3(); // Normal in the contact, pointing *out* of whatever the player touched
      var upAxis = new CANNON.Vec3(0, 1, 0);
      cannonBody.addEventListener("collide", function(e) {
        var contact = e.contact;

        // contact.bi and contact.bj are the colliding bodies, and contact.ni is the collision normal.
        // We do not yet know which one is which! Let's check.
        if (contact.bi.id == cannonBody.id) // bi is the player body, flip the contact normal
          contact.ni.negate(contactNormal);
        else
          contactNormal.copy(contact.ni); // bi is something else. Keep the normal as it is

        // If contactNormal.dot(upAxis) is between 0 and 1, we know that the contact normal is somewhat in the up direction.
        if (contactNormal.dot(upAxis) > 0.5) // Use a "good" threshold value between 0 and 1 here!
          canJump = true;
      });

      var velocity = cannonBody.velocity;

      var PI_2 = Math.PI / 2;

      // maybe fix this later to use ray caster instead of yawObject
      var onMouseMove = function(event) {

        if (scope.enabled === false) return;

        var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

        yawObject.rotation.y -= movementX * 0.002;
        pitchObject.rotation.x -= movementY * 0.002;

        pitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));
      };

      var onKeyDown = function(event) {

        switch (event.keyCode) {

          case 38: // up
          case 87: // w
            socket.emit('moveForward', {
              position: {
                x: sphereBody.position.x,
                y: sphereBody.position.y,
                z: sphereBody.position.z
              },
              id: socket.id
            })
            moveForward = true;
            break;

          case 37: // left
          case 65: // a
            moveLeft = true;
            break;

          case 40: // down
          case 83: // s
            moveBackward = true;
            break;

          case 39: // right
          case 68: // d
            moveRight = true;
            break;

          case 32: // space
            if (canJump === true) {
              velocity.y = jumpVelocity;
            }
            canJump = false;
            break;
        }

      };

      var onKeyUp = function(event) {

        switch (event.keyCode) {

          case 38: // up
          case 87: // w
            moveForward = false;
            break;

          case 37: // left
          case 65: // a
            moveLeft = false;
            break;

          case 40: // down
          case 83: // a
            moveBackward = false;
            break;

          case 39: // right
          case 68: // d
            moveRight = false;
            break;

        }

      };

      document.addEventListener('mousemove', onMouseMove, false);
      document.addEventListener('keydown', onKeyDown, false);
      document.addEventListener('keyup', onKeyUp, false);

      this.enabled = false;

      this.getObject = function() {
        return yawObject;
      };

      this.getDirection = function(targetVec) {
        targetVec.set(0, 0, -1);
        quat.multiplyVector3(targetVec);
      }

      // Moves the camera to the Cannon.js object position and adds velocity to the object if the run key is down
      var inputVelocity = new THREE.Vector3();
      var euler = new THREE.Euler();
      this.update = function(delta) {

        if (scope.enabled === false) return;

        delta *= 0.1;

        inputVelocity.set(0, 0, 0);

        if (moveForward) {
          inputVelocity.z = -velocityFactor * delta;
        }
        if (moveBackward) {
          inputVelocity.z = velocityFactor * delta;
        }

        if (moveLeft) {
          inputVelocity.x = -velocityFactor * delta;
        }
        if (moveRight) {
          inputVelocity.x = velocityFactor * delta;
        }

        // Convert velocity to world coordinates
        euler.x = pitchObject.rotation.x;
        euler.y = yawObject.rotation.y;
        euler.order = "XYZ";
        quat.setFromEuler(euler);
        inputVelocity.applyQuaternion(quat);
        //quat.multiplyVector3(inputVelocity);

        // Add to the object
        velocity.x += inputVelocity.x;
        velocity.z += inputVelocity.z;

        yawObject.position.copy(cannonBody.position);
      };
    };


  var sphereShape, sphereBody, world, physicsMaterial, walls=[], balls=[], ballMeshes=[], boxes=[], boxMeshes=[];
      var camera, scene, renderer;
      var geometry, material, mesh;
      var controls,time = Date.now();
      var blocker = document.getElementById( 'blocker' );
      var instructions = document.getElementById( 'instructions' );
      var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
      if ( havePointerLock ) {
          var element = document.body;
          var pointerlockchange = function ( event ) {
              if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
                  controls.enabled = true;
                  blocker.style.display = 'none';
              } else {
                  controls.enabled = false;
                  blocker.style.display = '-webkit-box';
                  blocker.style.display = '-moz-box';
                  blocker.style.display = 'box';
                  instructions.style.display = '';
              }
          }
          var pointerlockerror = function ( event ) {
              instructions.style.display = '';
          }
          // Hook pointer lock state change events
          document.addEventListener( 'pointerlockchange', pointerlockchange, false );
          document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
          document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );
          document.addEventListener( 'pointerlockerror', pointerlockerror, false );
          document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
          document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );
          instructions.addEventListener( 'click', function ( event ) {
              instructions.style.display = 'none';
              // Ask the browser to lock the pointer
              element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
              if ( /Firefox/i.test( navigator.userAgent ) ) {
                  var fullscreenchange = function ( event ) {
                      if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
                          document.removeEventListener( 'fullscreenchange', fullscreenchange );
                          document.removeEventListener( 'mozfullscreenchange', fullscreenchange );
                          element.requestPointerLock();
                      }
                  }
                  document.addEventListener( 'fullscreenchange', fullscreenchange, false );
                  document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );
                  element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;
                  element.requestFullscreen();
              } else {
                  element.requestPointerLock();
              }
          }, false );
      } else {
          instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';
      }
      initCannon();
      init();
      animate();

      function initCannon(){
      //     // Setup our world
          world = new CANNON.World();
          world.quatNormalizeSkip = 0;
          world.quatNormalizeFast = false;
          var solver = new CANNON.GSSolver();
          world.defaultContactMaterial.contactEquationStiffness = 1e9;
          world.defaultContactMaterial.contactEquationRelaxation = 4;
          solver.iterations = 7;
          solver.tolerance = 0.1;
          var split = true;
          if(split)
              world.solver = new CANNON.SplitSolver(solver);
          else
              world.solver = solver;
          world.gravity.set(0,-20,0);
          world.broadphase = new CANNON.NaiveBroadphase();

      //     // Create a slippery material (friction coefficient = 0.0)
          physicsMaterial = new CANNON.Material("slipperyMaterial");
          var physicsContactMaterial = new CANNON.ContactMaterial(physicsMaterial,
                                                                  physicsMaterial,
                                                                  0.0, // friction coefficient
                                                                  0.3  // restitution
                                                                  );
      //     // We must add the contact materials to the world
          world.addContactMaterial(physicsContactMaterial);

      //     // Create a sphere
          var mass = 5, radius = 1.3;
          sphereShape = new CANNON.Sphere(radius);
          sphereBody = new CANNON.Body({ mass: mass });
          sphereBody.addShape(sphereShape);
          sphereBody.position.set(0,5,0);
          sphereBody.linearDamping = 0.9;
          world.addBody(sphereBody);

          // Create a plane
          var groundShape = new CANNON.Plane();
          var groundBody = new CANNON.Body({ mass: 0 });
          groundBody.addShape(groundShape);
          groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
          world.addBody(groundBody);
      }

      function init() {
          camera = new THREE.PerspectiveCamera( 55, window.innerWidth / window.innerHeight, 0.1, 1000 );
          camera.position.set(0, 3, 0)
          scene = new THREE.Scene();
          scene.fog = new THREE.Fog( 0x000000, 0, 500 );
          var ambient = new THREE.AmbientLight( 0x111111 );
          scene.add( ambient );
          light = new THREE.SpotLight( 0xffffff );
          light.position.set( 10, 30, 20 );
          light.target.position.set( 0, 0, 0 );
          if(true){
              light.castShadow = false;
              light.shadowCameraNear = 20;
              light.shadowCameraFar = 50;//camera.far;
              light.shadowCameraFov = 40;
              light.shadowMapBias = 0.1;
              light.shadowMapDarkness = 0.7;
              light.shadowMapWidth = 2*512;
              light.shadowMapHeight = 2*512;
              //light.shadowCameraVisible = true;
          }
          scene.add( light );

          // this attaches bomb to the player (maybe)
          // look at PointerLockControls function
          // sphereBody.position = (0,5,0) so the sphere should be 5+ in y direction above camera

          controls = new PointerLockControls( camera , sphereBody );
          scene.add( controls.getObject() );
          // floor
          geometry = new THREE.PlaneGeometry( 125, 125, 50, 50 );
          geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );
          material = new THREE.MeshLambertMaterial( { color: 0xdddddd } );
          mesh = new THREE.Mesh( geometry, material );
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add( mesh );
          renderer = new THREE.WebGLRenderer();
          renderer.shadowMapEnabled = true;
          renderer.shadowMapSoft = true;
          renderer.setSize( window.innerWidth, window.innerHeight );
          renderer.setClearColor( scene.fog.color, 1 );
          document.body.appendChild( renderer.domElement );
          window.addEventListener( 'resize', onWindowResize, false );
          // Add boxes
          var halfExtents = new CANNON.Vec3(2,2,2);
          var boxShape = new CANNON.Box(halfExtents);
          var boxGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*2,halfExtents.z*2);

          var wallShape = new CANNON.Box(halfExtents);
          var wallGeometry = new THREE.BoxGeometry(halfExtents.x*2,halfExtents.y*3.5,halfExtents.z*2);

          // // Map 1 = Wall, 2 = StaticBox
          let map = [ // 1  2  3  4  5  6  7  8  9  10 11 12
                     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 0
                     [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 1
                     [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1], // 2
                     [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 3
                     [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1], // 4
                     [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 5
                     [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1], // 6
                     [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 7
                     [1, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 1], // 8
                     [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], // 9
                     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], // 10
                     ], mapW = map.length, mapH = map[0].length;

          // // Walls
          //   let cube = new THREE.CubeGeometry(UNITSIZE, WALLHEIGHT, UNITSIZE);

              for (let j = 0; j < mapW; j++) {
                for (let k = 0; k < mapH; k++) {
                  if (map[j][k] === 2) {
                    let x = (j + mapW) * 4 - 65 / Math.sqrt(2); //
                    let  y = 2
                    let z = -(k + mapW) * 4 + 65 / Math.sqrt(2); //

                    var boxBody = new CANNON.Body({ mass: 0 });
                    boxBody.addShape(boxShape);
                    var boxMesh = new THREE.Mesh( boxGeometry, material );
                    world.addBody(boxBody);
                    scene.add(boxMesh);
                    boxBody.position.set(x,y,z);
                    boxMesh.position.set(x,y,z);
                    boxMesh.castShadow = true;
                    boxMesh.receiveShadow = true;
                    boxes.push(boxBody);
                    boxMeshes.push(boxMesh);
                  } else if (map[j][k] === 1){
                    let x = (j + mapW) * 4 - 65 / Math.sqrt(2); //
                    let  y = 2
                    let z = -(k + mapW) * 4 + 65 / Math.sqrt(2); //

                    var wallBody = new CANNON.Body({ mass: 0 });
                    wallBody.addShape(wallShape);
                    var wallMesh = new THREE.Mesh( wallGeometry, material );
                    world.addBody(wallBody);
                    scene.add(wallMesh);
                    wallBody.position.set(x,y,z);
                    wallMesh.position.set(x,y,z);
                    wallMesh.castShadow = true;
                    wallMesh.receiveShadow = true;
                    // boxes.push(wallBody);
                    // boxMeshes.push(wallMesh);
                  }
                }
              }


          // }
          // Add linked boxes
          // var size = 0.5;
          // var he = new CANNON.Vec3(size,size,size*0.1);
          // var boxShape = new CANNON.Box(he);
          // var mass = 0;
          // var space = 0.1 * size;
          // var N = 5, last;
          // var boxGeometry = new THREE.BoxGeometry(he.x*2,he.y*2,he.z*2);
          // for(var i=0; i<N; i++){
          //     var boxbody = new CANNON.Body({ mass: mass });
          //     boxbody.addShape(boxShape);
          //     var boxMesh = new THREE.Mesh(boxGeometry, material);
          //     boxbody.position.set(5,(N-i)*(size*2+2*space) + size*2+space,0);
          //     boxbody.linearDamping = 0.01;
          //     boxbody.angularDamping = 0.01;
          //     // boxMesh.castShadow = true;
          //     boxMesh.receiveShadow = true;
          //     world.addBody(boxbody);
          //     scene.add(boxMesh);
          //     boxes.push(boxbody);
          //     boxMeshes.push(boxMesh);
          //     if(i!=0){
          //         // Connect this body to the last one
          //         var c1 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(-size,size+space,0),last,new CANNON.Vec3(-size,-size-space,0));
          //         var c2 = new CANNON.PointToPointConstraint(boxbody,new CANNON.Vec3(size,size+space,0),last,new CANNON.Vec3(size,-size-space,0));
          //         world.addConstraint(c1);
          //         world.addConstraint(c2);
          //     } else {
          //         mass=0.3;
          //     }
          //     last = boxbody;
          // }
      }

      function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize( window.innerWidth, window.innerHeight );
      }

      var dt = 1/60; // change in time for walking

      // animate the walking and the box positions movements

      function animate() {
          requestAnimationFrame( animate );
          if(controls.enabled){
              world.step(dt); // function that allows walking from CANNON

              // Update ball positions
              // the bombs in our game
              for(var i=0; i<balls.length; i++){
                  ballMeshes[i].position.copy(balls[i].position);
                  ballMeshes[i].quaternion.copy(balls[i].quaternion);
              }
              // // Update box positions
              // for(var i=0; i<boxes.length; i++){
              //     boxMeshes[i].position.copy(boxes[i].position);
              //     boxMeshes[i].quaternion.copy(boxes[i].quaternion);
              // }
          }

          controls.update( Date.now() - time );
          renderer.render( scene, camera );
          time = Date.now();
      }


      // SHOOTING BOMBS HERE

       // cannon sphere(radius)
      var ballShape = new CANNON.Sphere(1.5);

      // three sphere(radius, numFaces per xyz) higher num means rounder sphere
      // 32 should be enough for spheres
      var ballGeometry = new THREE.SphereGeometry(ballShape.radius, 32, 32);

      // generates a vector with no units if you want units you input
      // Vector3(x,y,z)
      var shootDirection = new THREE.Vector3();

      // speed of ball (m/s maybe?)
      var shootVelo = 15;

      // this is outdated should use raycaster instead since it gives more info anyway
      // also projector is moved.
      // to adjust to use raycaster we need to adjust yawObject and pitch object

      TODO: // HERE
      var projector = new THREE.Projector();

      // get shoot direction might need to be adjusted to use ray caster instead
      function getShootDir(targetVec){
          var vector = targetVec;
          targetVec.set(0,0,1);
          projector.unprojectVector(vector, camera);
          var ray = new THREE.Ray(sphereBody.position, vector.sub(sphereBody.position).normalize() );
          targetVec.copy(ray.direction);
      }

      // add event listen to actually shoot
      window.addEventListener("click",function(e){
          if(controls.enabled==true){

              // because sphereBody position is dependent on camera position
              var x = sphereBody.position.x;
              var y = sphereBody.position.y;
              var z = sphereBody.position.z;

              // create the ball
              var ballBody = new CANNON.Body({ mass: 1 });
              ballBody.addShape(ballShape);
              var ballMesh = new THREE.Mesh( ballGeometry, material );
              world.addBody(ballBody);

              // add it to the scene
              scene.add(ballMesh);

              // shadow affects
              ballMesh.castShadow = true;
              ballMesh.receiveShadow = true;

              // push it into our global balls array

              balls.push(ballBody);

              // push ball meshes
              ballMeshes.push(ballMesh);

              // get its direction using getShootDir function
              // returns shootDirection altered with correct data
              getShootDir(shootDirection);


              // give it a velocity
              // shootVelo is global defined as 15
              ballBody.velocity.set(  shootDirection.x * shootVelo,
                                      shootDirection.y * shootVelo,
                                      shootDirection.z * shootVelo);

              // Move the ball outside the player sphere
              // not sure about this shit here
              // x,y,z adjusted so it's actually updating the position of the sphere
              x += shootDirection.x * (sphereShape.radius*1.02 + ballShape.radius);
              y += shootDirection.y * (sphereShape.radius*1.02 + ballShape.radius);
              z += shootDirection.z * (sphereShape.radius*1.02 + ballShape.radius);
              ballBody.position.set(x,y,z);
              ballMesh.position.set(x,y,z);
                }
            });
    </script>
  </body>
</html>
